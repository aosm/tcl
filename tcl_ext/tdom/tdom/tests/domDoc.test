# Features covered: domDoc and docObj command
#
# This file contains a collection of tests for the two interfaces to
# DOM docs, the token interface (the domDoc command) and the tcl
# command interface ([$docObj method ...]).
#
#    domDoc-1.*:  asXML, asHTML
#    domDoc-2.*:  publicId, systemId
#    domDoc-3.*:  toXSLTcmd
#    domDoc-4.*:  asText
#    domDoc-5.*:  normalize
#
# Copyright (c) 2004 Rolf Ade.

source [file join [file dir [info script]] loadtdom.tcl]

test domDoc-1.1 {asXML -escapeNonASCII} {need_i18n} {
    set doc [dom parse [tDOM::xmlReadFile \
            [file join [file dir [info script]] data/i18n_1.xml]]]
    set result [$doc asXML -escapeNonASCII]
    $doc delete
    set result
} {<test>&#1072;&#1073;&#1074;&#1075;&#1076;&#1077;&#1078;&#1079;&#1080;&#1081;</test>
}

test domDoc-1.2 {asXML -escapeNonASCII; comments and PI's are not altered} {need_i18n} {
    set doc [dom parse [tDOM::xmlReadFile \
            [file join [file dir [info script]] data/i18n_2.xml]]]
    set result [$doc asXML -indent none -escapeNonASCII]
    $doc delete
    set result
} {<root withUmlauts="&#228;&#246;&#252;&#223;"><!-- A comment with german umlauts: äöüß --><?äöüß A processing node with german umlauts?>
german umlauts: &#228;&#246;&#252;&#223;
</root>}

test domDoc-1.3 {asHTML -escapeNonASCII -htmlEntities} {need_i18n} {
    set doc [dom parse {<html><body>&#228;&#xfc;&#8222;&#8223;&#8224;</body></html>}]
    set result [$doc asHTML -escapeNonASCII -htmlEntities]
    $doc delete
    set result
} {<html><body>&auml;&uuml;&bdquo;&#8223;&dagger;</body></html>}


set doc [dom parse <root/>]

test domDoc-1.4 {asXML -doctypeDeclaration} {
    $doc asXML -doctypeDeclaration 1
} {<!DOCTYPE root>
<root/>
}

test domDoc-1.5 {asXML -doctypeDeclaration without boolean value (error)} {
    set errMsg ""
    catch {$doc asXML -doctypeDeclaration} errMsg
    set errMsg
} {-doctypeDeclaration must have a boolean value as argument}

test domDoc-1.6 {asXML -doctypeDeclaration 0} {
    $doc asXML -doctypeDeclaration 0
} {<root/>
}

$doc delete

test domDoc-1.7 {asXML -doctypeDeclaration} {
    set doc [dom parse {<!DOCTYPE root PUBLIC "-//foo//DTD bar x.y//EN" 
                                       "file:///boo.baz"><root/>}]
    set result [$doc asXML -doctypeDeclaration 1]
    $doc delete
    set result
} {<!DOCTYPE root PUBLIC "-//foo//DTD bar x.y//EN" "file:///boo.baz">
<root/>
}

test domDoc-1.8 {asXML -doctypeDeclaration} {
    set doc [dom parse {<!DOCTYPE root SYSTEM "file:///boo.baz"><root/>}]
    set result [$doc asXML -doctypeDeclaration 1]
    $doc delete
    set result
} {<!DOCTYPE root SYSTEM "file:///boo.baz">
<root/>
}   

test domDoc-1.9 {asXML -doctypeDeclaration} {
    set doc [dom parse {<!DOCTYPE root SYSTEM "file:///boo.baz"><root/>}]
    set result [$doc asXML -doctypeDeclaration true]
    $doc delete
    set result
} {<!DOCTYPE root SYSTEM "file:///boo.baz">
<root/>
}   

test domDoc-1.10 {asXML - unknown option} {
    set doc [dom parse {<!DOCTYPE root SYSTEM "file:///boo.baz"><root/>}]
    set errMsg ""
    catch {$doc asXML -fooOption 1} errMsg
    $doc delete
    set errMsg
} {bad option "-fooOption": must be -indent, -channel, -escapeNonASCII, or -doctypeDeclaration}

test domDoc-1.11 {asXML - non boolean value to -doctypeDeclaration} {
    set doc [dom parse {<!DOCTYPE root SYSTEM "file:///boo.baz"><root/>}]
    set errMsg ""
    catch {$doc asXML -doctypeDeclaration foo} errMsg
    $doc delete
    set errMsg
} {expected boolean value but got "foo"}

test domDoc-1.12 {asXML - shortened option} {
    set doc [dom parse {<!DOCTYPE root SYSTEM "file:///boo.baz"><root/>}]
    set result [$doc asXML -doctype 1]
    $doc delete
    set result
} {<!DOCTYPE root SYSTEM "file:///boo.baz">
<root/>
}   

test domDoc-1.13 {asHTML -doctypeDeclaration} {
    set doc [dom createDocument HTML]
    set result [$doc asHTML -doctypeDeclaration 1]
    $doc delete
    set result
} {<!DOCTYPE HTML>
<html></html>}

test domDoc-1.14 {asHTML -doctypeDeclaration} {
    set doc [dom parse {<!DOCTYPE HTML 
    PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
    <html><body><p>boo</p></body></html>}]
    set result [$doc asHTML -doctypeDeclaration 1]
    $doc delete
    set result
} {<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body><p>boo</p></body></html>}

set doc [dom parse <root/>]

test domDoc-2.1 {publicId - no publicId there} {
    $doc publicId
} {}

test domDoc-2.2 {systemId - no systemId there} {
    $doc systemId
} {}

$doc delete
set doc [dom parse {<!DOCTYPE root PUBLIC "-//foo//DTD bar x.y//EN" "file:///boo.baz"><root/>}]

test domDoc-2.3 {publicId from parsed document} {
    $doc publicId
} {-//foo//DTD bar x.y//EN}

test domDoc-2.4 {systemId from parsed document} {
    $doc systemId
} {file:///boo.baz}

$doc delete
set doc [dom parse {<!DOCTYPE root SYSTEM "file:///boo.baz"><root/>}]

test domDoc-2.5 {publicId but document has only SYSTEM} {
    $doc publicId
} {}

test domDoc-2.6 {systemId, document has only SYSTEM} {
    $doc systemId
} {file:///boo.baz}

test domDoc-2.7 {publicId - set public identifier} {
    set result [$doc publicId "file:///woo.hoo"]
    append result " [$doc publicId]"
} { file:///woo.hoo} 

test domDoc-2.8 {publicId - set public identifier} {
    $doc publicId "http://www.tdom.org"
    $doc asXML -indent no -doctypeDeclaration 1
} {<!DOCTYPE root PUBLIC "http://www.tdom.org" "file:///boo.baz">
<root/>}

test domDoc-2.9 {systemId - set system identifier} {
    set result [$doc systemId "file:///woo.hoo"]
    append result " [$doc systemId]"
} {file:///boo.baz file:///woo.hoo}

test domDoc-2.10 {systemId - set system identifier} {
    $doc systemId "file:///whooze.moo"
    $doc asXML -indent no -doctypeDeclaration 1
} {<!DOCTYPE root PUBLIC "http://www.tdom.org" "file:///whooze.moo">
<root/>}

test domDoc-2.11 {publicId - set to empty string} {
    $doc publicId ""
    $doc asXML -indent no -doctypeDeclaration 1
} {<!DOCTYPE root SYSTEM "file:///whooze.moo">
<root/>}

test domDoc-2.12 {systemId - set to empty string} {
    $doc systemId ""
    $doc asXML -indent no -doctypeDeclaration 1
} {<!DOCTYPE root>
<root/>}

$doc delete



set doc [dom parse <root/>]

set xslt1 {
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:param name="param1" select="'param1Default'"/>
    <xsl:param name="param2" select="'param2Default'"/>
    <xsl:param name="param3" select="'param3Default'"/>
    <xsl:template match="/">
        <xsl:value-of select="$param1"/>
        <xsl:text> </xsl:text>
        <xsl:value-of select="$param2"/>
        <xsl:text> </xsl:text>
        <xsl:value-of select="$param3"/>
        <xsl:text> </xsl:text>
    </xsl:template>
</xsl:stylesheet>}

test domDoc-3.1 {toXSLTcmd} {
    set xslt [dom parse -keepEmpties $xslt1]
    set xsltCmd [$xslt toXSLTcmd]
    
    $xsltCmd -parameters {param2 newValue param3 "this Value"} $doc resultDoc
    set result [$resultDoc asXML -indent none]
    $resultDoc delete
    $xsltCmd -parameters {param1 "that Value"} $doc resultDoc
    append result [$resultDoc asXML -indent none]
    $resultDoc delete
    $xsltCmd -parameters {param3 "another" param1 "and this"} $doc resultDoc
    append result [$resultDoc asXML -indent none]
    $resultDoc delete
    rename $xsltCmd {}
    set result
} {param1Default newValue this Value that Value param2Default param3Default and this param2Default another }

set xslt2 {
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
    <xsl:template match="/">
        <xsl:text>dummy result</xsl:text>
        <xsl:message>This is from xsl:message</xsl:message>
    </xsl:template>
</xsl:stylesheet>}

proc msgCmd1 {msg terminate} {
    global result
    append result "msgCmd1: $msg "
}

proc msgCmd2 {msg terminate} {
    global result
    append result "msgCmd2: $msg"
}

test domDoc-3.2 {toXSLTcmd} {
    set xslt [dom parse -keepEmpties $xslt2]
    set xsltCmd [$xslt toXSLTcmd]

    set result ""
    $xsltCmd -xsltmessagecmd msgCmd1 $doc resultDoc
    $resultDoc delete
    $xsltCmd -xsltmessagecmd msgCmd2 $doc resultDoc
    $resultDoc delete
    rename $xsltCmd {}
    set result
} {msgCmd1: This is from xsl:message msgCmd2: This is from xsl:message}

test domDoc-3.3 {toXSLTcmd} {
    set xslt [dom parse -keepEmpties $xslt1]
    set xsltCmd [$xslt toXSLTcmd]

    set result [catch {$xsltCmd -bogusOption foo $doc resultDoc} errMsg]
    lappend result $errMsg
    lappend result [catch {$xsltCmd $doc resultDoc}]
    lappend result [$resultDoc asXML -indent none]
    $resultDoc delete
    rename $xsltCmd {}
    set result
} {1 {bad option "-bogusOption": must be -parameters, -ignoreUndeclaredParameters, or -xsltmessagecmd} 0 {param1Default param2Default param3Default }}

test domDoc-3.4 {toXSLTcmd} {
    set xslt [dom parse -keepEmpties $xslt1]
    set xsltCmd [$xslt toXSLTcmd]

    set result [catch {$xsltCmd -xsltmessagecmd msgCmd1} errMsg]
    rename $xsltCmd {}
    lappend result $errMsg
} {1 {wrong # args: should be "?-parameters parameterList? ?-ignoreUndeclaredParameters? ?-xsltmessagecmd cmd? <xmlDocObj> ?objVar?"}}

test domDoc-3.5 {toXSLTcmd} {
    set xslt [dom parse -keepEmpties $xslt1]
    set xsltCmd [$xslt toXSLTcmd]

    set result [catch {$xsltCmd $doc resultDoc bogus} errMsg]
    rename $xsltCmd {}
    lappend result $errMsg
} {1 {wrong # args: should be "?-parameters parameterList? ?-ignoreUndeclaredParameters? ?-xsltmessagecmd cmd? <xmlDocObj> ?objVar?"}}

test domDoc-3.6 {toXSLTcmd} {
    set xslt [dom parse -keepEmpties $xslt1]
    set xsltCmd [$xslt toXSLTcmd]

    set result [catch {$xsltCmd -parameters {param1 foo} -parameters {param2 foo} $doc resultDoc} errMsg]
    rename $xsltCmd {}
    lappend result $errMsg
} {1 {only one -parameters option allowed}}

$doc delete

test domDoc-4.1 {asText - syntax check} {
    dom parse <root/> doc
    set result [catch {$doc asText foo}]
    $doc delete
    set result
} {1}

test domDoc-4.2 {asText} {
    dom parse {<root>pcdata <child>foo bar grill</child></root>} doc
    set result [$doc asText]
    $doc delete
    set result
} {pcdata foo bar grill}

test domDoc-4.3 {asText} {
    dom parse {<root>pcdata <![CDATA[<greeting>Hello, world!</greeting>]]>
        more pcdata</root>} doc
    set result [$doc asText]
    $doc delete
    set result
} {pcdata <greeting>Hello, world!</greeting>
        more pcdata}

test domDoc-4.4 {asText} {
    dom parse {<root>pcdata</root>} doc
    $doc documentElement root
    set newCDATAnode \
        [$doc createCDATASection "<greeting>Hello, world!</greeting>"]
    $root appendChild $newCDATAnode
    set result [$doc asText]
    $doc delete
    set result
} {pcdata}

test domDoc-4.5 {asText} {
    dom parse {<root>encoded chars: &gt; &lt; &amp; &quot; &apos;</root>} doc
    set result [$doc asText]
    $doc delete
    set result
} {encoded chars: > < & " '}
# emacs: "


test domDoc-5.1 {normalize} {
    set doc [dom parse <root><child>text</child></root>]
    $doc documentElement root
    set cdataNode [$doc createCDATASection "cdata section text"]
    set child [$root firstChild]
    $child appendChild $cdataNode
    $doc normalize
    set result [llength [$child childNodes]]
    lappend result [[$child firstChild] data]
    $doc delete
    set result
} {2 text}

test domDoc-5.2 {normalize} {
    set doc [dom parse <root><child>text</child></root>]
    $doc documentElement root
    set cdataNode [$doc createCDATASection "cdata section text"]
    set child [$root firstChild]
    $child appendChild $cdataNode
    $doc normalize -forXPath
    set result [llength [$child childNodes]]
    lappend result [[$child firstChild] data]
    $doc delete
    set result
} {1 {textcdata section text}}

test domDoc-5.3 {normalize} {
    set doc [dom parse <root><child/></root>]
    $doc documentElement root
    set cdataNode [$doc createCDATASection "cdata section text"]
    set textNode [$doc createTextNode text]
    set child [$root firstChild]
    $child appendChild $cdataNode
    $child appendChild $textNode
    set result [llength [$child childNodes]]
    $doc normalize -forXPath
    lappend result [llength [$child childNodes]]
    lappend result [[$child firstChild] data]
    $doc delete
    set result
} {2 1 {cdata section texttext}}

test domDoc-5.4 {normalize} {
    set doc [dom parse <root><child/></root>]
    $doc documentElement root
    set cdataNode [$doc createCDATASection "cdata section text"]
    set child [$root firstChild]
    $child appendChild $cdataNode
    $doc normalize
    set result [$cdataNode nodeType]
    $doc normalize -forXPath
    lappend result [$cdataNode nodeType]
    $doc delete
    set result
} {CDATA_SECTION_NODE TEXT_NODE}

test domDoc-5.5 {normalize} {
    set doc [dom parse <root><child/></root>]
    $doc documentElement root
    set textNode [$doc createTextNode ""]
    set child [$root firstChild]
    $child appendChild $textNode
    set result [llength [$child childNodes]]
    $doc normalize
    lappend result [llength [$child childNodes]]
    $doc delete
    set result
} {1 0}

test domDoc-5.6 {normalize} {
    set doc [dom parse <root><child/></root>]
    $doc documentElement root
    set cdataNode [$doc createCDATASection ""]
    set child [$root firstChild]
    $child appendChild $cdataNode
    $doc normalize
    set result [llength [$child childNodes]]
    $doc normalize -forXPath
    lappend result [llength [$child childNodes]]
    $doc delete
    set result
} {1 0}
